<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Y√™u em p√© nh·∫•t, Ch√∫c em p√© c√≥ 1/6 vui v·∫ª</title>
  <!-- Link to local Tailwind CSS output -->
  <link href="output.css" rel="stylesheet">
  <!-- MathJax CDN -->
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <!-- Math.js CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.8.0/math.min.js"></script>
  <style>
    body {
      background: linear-gradient(135deg, #ff9a9e, #fad0c4);
      overflow: hidden;
      font-family: 'Arial', sans-serif;
    }
    canvas {
      position: absolute;
      top: 0;
      left: 0;
      z-index: 0;
    }
    .content {
      position: relative;
      z-index: 1;
    }
    /* ·∫®n video YouTube, ch·ªâ ph√°t √¢m thanh */
    .youtube-audio {
      position: absolute;
      width: 0;
      height: 0;
      visibility: hidden;
    }
    .carousel {
      display: flex;
      overflow-x: auto;
      gap: 10px;
      padding: 10px;
      scroll-behavior: smooth;
    }
    .carousel img {
      min-width: 300px;
      max-width: 300px;
      height: auto;
      object-fit: cover;
      border-radius: 10px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }
  </style>
</head>
<body>
  <!-- Nh√∫ng video YouTube t·ª´ gi√¢y 0:42 -->
  <iframe class="youtube-audio" src="https://www.youtube.com/embed/js6JBdLzNn4?start=42&autoplay=1&mute=0&controls=0&showinfo=0&rel=0&loop=1&playlist=js6JBdLzNn4" frameborder="0" allow="autoplay; encrypted-media"></iframe>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    // C√†i ƒë·∫∑t canvas
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    // M·∫£ng l∆∞u tr·ªØ tr√°i tim, ng√¥i sao, vƒÉn b·∫£n v√† h√¨nh ·∫£nh xoay
    const hearts = [];
    const stars = [];
    const texts = [];
    const orbitingImages = [];

    // Danh s√°ch c√°c c√¢u s·∫øn s√∫a
    const messages = [
      "Y√™u em p√© nh·∫•t, Ch√∫c em p√© c√≥ 1/6 vui v·∫ª üíï",
      "Anh nguy·ªán l√†m m·∫∑t tr·ªùi, soi s√°ng c·∫£ th·∫ø gi·ªõi c·ªßa em üåû",
      "Em p√© l√† ng√¥i sao s√°ng nh·∫•t trong b·∫ßu tr·ªùi c·ªßa anh ‚ú®",
      "T√¨nh y√™u c·ªßa anh d√†nh cho em p√© l√† m√£i m√£i üíñ",
      "Ch·ªâ c·∫ßn em p√© vui, anh nguy·ªán l√†m t·∫•t c·∫£ üåà",
      "Em p√© l√† c·∫£ th·∫ø gi·ªõi trong tr√°i tim anh üíå",
      "Anh s·∫Ω m√£i b√™n em p√©, nh∆∞ ng√¥i sao kh√¥ng r·ªùi b·∫ßu tr·ªùi üåü",
      "Y√™u em p√© h∆°n c·∫£ nh·ªØng v√¨ sao tr√™n tr·ªùi üí´",
      "Ch√∫c em p√© ng√†y 1/6 tr√†n ng·∫≠p ni·ªÅm vui v√† h·∫°nh ph√∫c üéà"
    ];

    // Danh s√°ch URL h√¨nh ·∫£nh (chuy·ªÉn sang local files)
    const imageUrls = [
      'image1.jpg', // Thay b·∫±ng file b·∫°n t·∫£i t·ª´ https://pin.it/6sXUpqI7M
      'image2.jpg', // Thay b·∫±ng file b·∫°n t·∫£i t·ª´ https://pin.it/6sXUpqI7M (ho·∫∑c link kh√°c)
      'image3.jpg'  // Thay b·∫±ng file b·∫°n t·∫£i t·ª´ https://pin.it/5EE7cXSWk
    ];

    // L·ªõp Heart (Tr√°i tim)
    class Heart {
      constructor(x, y, size, speed) {
        this.x = x;
        this.y = y;
        this.size = size;
        this.speed = speed;
        this.color = `hsl(${Math.random() * 360}, 70%, 60%)`;
        this.opacity = 1;
      }

      draw() {
        ctx.globalAlpha = this.opacity;
        ctx.beginPath();
        ctx.moveTo(this.x, this.y + this.size / 4);
        ctx.quadraticCurveTo(this.x - this.size / 2, this.y - this.size / 2, this.x - this.size, this.y + this.size / 4);
        ctx.quadraticCurveTo(this.x - this.size / 2, this.y + this.size, this.x, this.y + 3 * this.size / 4);
        ctx.quadraticCurveTo(this.x + this.size / 2, this.y + this.size, this.x + this.size, this.y + this.size / 4);
        ctx.quadraticCurveTo(this.x + this.size / 2, this.y - this.size / 2, this.x, this.y + this.size / 4);
        ctx.fillStyle = this.color;
        ctx.fill();
        ctx.globalAlpha = 1;
      }

      update() {
        this.y -= this.speed;
        this.opacity -= 0.005;
        if (this.opacity <= 0) return false;
        return true;
      }
    }

    // L·ªõp Star (Ng√¥i sao l·∫•p l√°nh)
    class Star {
      constructor(x, y, size) {
        this.x = x;
        this.y = y;
        this.size = size;
        this.opacity = Math.random();
        this.deltaOpacity = Math.random() * 0.05;
      }

      draw() {
        ctx.globalAlpha = this.opacity;
        ctx.beginPath();
        for (let i = 0; i < 5; i++) {
          const angle = (Math.PI * 2 / 5) * i - Math.PI / 2;
          const outerX = this.x + Math.cos(angle) * this.size;
          const outerY = this.y + Math.sin(angle) * this.size;
          const innerAngle = angle + (Math.PI * 2 / 10);
          const innerX = this.x + Math.cos(innerAngle) * (this.size / 2);
          const innerY = this.y + Math.sin(innerAngle) * (this.size / 2);
          if (i === 0) ctx.moveTo(outerX, outerY);
          else ctx.lineTo(outerX, outerY);
          ctx.lineTo(innerX, innerY);
        }
        ctx.closePath();
        ctx.fillStyle = '#fff';
        ctx.fill();
        ctx.globalAlpha = 1;
      }

      update() {
        this.opacity += this.deltaOpacity;
        if (this.opacity >= 1 || this.opacity <= 0) this.deltaOpacity *= -1;
      }
    }

    // L·ªõp Text (VƒÉn b·∫£n n·ªïi l√™n)
    class Text {
      constructor(x, y, message, speed) {
        this.x = x;
        this.y = y;
        this.message = message;
        this.speed = speed;
        this.opacity = 1;
        this.color = `hsl(${Math.random() * 360}, 70%, 60%)`;
      }

      draw() {
        ctx.globalAlpha = this.opacity;
        ctx.font = 'bold 24px Arial';
        ctx.fillStyle = this.color;
        ctx.textAlign = 'center';
        ctx.fillText(this.message, this.x, this.y);
        ctx.globalAlpha = 1;
      }

      update() {
        this.y -= this.speed;
        this.opacity -= 0.005;
        if (this.opacity <= 0) return false;
        return true;
      }
    }

    // L·ªõp OrbitingImage (H√¨nh ·∫£nh xoay quanh trung t√¢m)
    class OrbitingImage {
      constructor(url, centerX, centerY, radius, speed, size) {
        this.image = new Image();
        this.image.crossOrigin = "anonymous"; // Handle CORS
        this.image.src = url;
        this.centerX = centerX;
        this.centerY = centerY;
        this.radius = radius;
        this.angle = Math.random() * Math.PI * 2; // G√≥c ng·∫´u nhi√™n ban ƒë·∫ßu
        this.speed = speed;
        this.size = size;
        this.isLoaded = false;
        this.hasError = false;

        // Wait for image to load
        this.image.onload = () => {
          this.isLoaded = true;
        };

        // Handle load errors
        this.image.onerror = () => {
          this.hasError = true;
          console.error(`Failed to load image: ${url}`);
        };
      }

      draw() {
        // Only draw if the image is loaded and there are no errors
        if (this.isLoaded && !this.hasError) {
          const x = this.centerX + Math.cos(this.angle) * this.radius;
          const y = this.centerY + Math.sin(this.angle) * this.radius;
          ctx.drawImage(this.image, x - this.size / 2, y - this.size / 2, this.size, this.size);
        }
      }

      update() {
        this.angle += this.speed;
        if (this.angle > Math.PI * 2) this.angle -= Math.PI * 2;
      }
    }

    // T·∫°o tr√°i tim m·ªõi
    function spawnHeart() {
      const x = Math.random() * canvas.width;
      const y = canvas.height;
      const size = Math.random() * 20 + 10;
      const speed = Math.random() * 2 + 1;
      hearts.push(new Heart(x, y, size, speed));
    }

    // T·∫°o ng√¥i sao l·∫•p l√°nh
    function spawnStar() {
      const x = Math.random() * canvas.width;
      const y = Math.random() * canvas.height;
      const size = Math.random() * 5 + 2;
      stars.push(new Star(x, y, size));
    }

    // T·∫°o vƒÉn b·∫£n m·ªõi
    function spawnText() {
      const x = Math.random() * canvas.width;
      const y = canvas.height;
      const message = messages[Math.floor(Math.random() * messages.length)];
      const speed = Math.random() * 1.5 + 0.5;
      texts.push(new Text(x, y, message, speed));
    }

    // Kh·ªüi t·∫°o c√°c ng√¥i sao
    for (let i = 0; i < 50; i++) spawnStar();

    // Kh·ªüi t·∫°o c√°c h√¨nh ·∫£nh xoay quanh trung t√¢m
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;
    imageUrls.forEach((url, index) => {
      const radius = 150 + index * 20; // Kho·∫£ng c√°ch t·ª´ trung t√¢m (kh√°c nhau cho m·ªói h√¨nh)
      const speed = 0.02 - index * 0.005; // T·ªëc ƒë·ªô xoay (h√¨nh ngo√†i xoay ch·∫≠m h∆°n)
      const size = 60; // K√≠ch th∆∞·ªõc h√¨nh ·∫£nh
      orbitingImages.push(new OrbitingImage(url, centerX, centerY, radius, speed, size));
    });

    // V√≤ng l·∫∑p animation
    function animate() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // T·∫°o tr√°i tim v√† vƒÉn b·∫£n m·ªõi
      if (Math.random() < 0.1) spawnHeart();
      if (Math.random() < 0.05) spawnText();

      // C·∫≠p nh·∫≠t v√† v·∫Ω tr√°i tim
      for (let i = hearts.length - 1; i >= 0; i--) {
        hearts[i].draw();
        if (!hearts[i].update()) hearts.splice(i, 1);
      }

      // C·∫≠p nh·∫≠t v√† v·∫Ω ng√¥i sao
      stars.forEach(star => {
        star.draw();
        star.update();
      });

      // C·∫≠p nh·∫≠t v√† v·∫Ω vƒÉn b·∫£n
      for (let i = texts.length - 1; i >= 0; i--) {
        texts[i].draw();
        if (!texts[i].update()) texts.splice(i, 1);
      }

      // C·∫≠p nh·∫≠t v√† v·∫Ω h√¨nh ·∫£nh xoay
      orbitingImages.forEach(image => {
        image.draw();
        image.update();
      });

      requestAnimationFrame(animate);
    }

    animate();

    // X·ª≠ l√Ω resize
    window.addEventListener('resize', () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      // C·∫≠p nh·∫≠t l·∫°i trung t√¢m khi thay ƒë·ªïi k√≠ch th∆∞·ªõc
      orbitingImages.forEach(image => {
        image.centerX = canvas.width / 2;
        image.centerY = canvas.height / 2;
      });
    });
  </script>
</body>
</html>
